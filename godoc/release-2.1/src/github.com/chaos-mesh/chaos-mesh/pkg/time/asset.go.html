<!DOCTYPE html><html><head>
<meta http-equiv="Content-Type" content="text/html; charset=utf-8"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<meta name="theme-color" content="#375EAB"/>

  <title>src/github.com/chaos-mesh/chaos-mesh/pkg/time/asset.go - Chaos Mesh</title>

<link type="text/css" rel="stylesheet" href="https://chaos-mesh.dev/godoc/release-2.1/lib/godoc/style.css"/>

<script>window.initFuncs = [];</script>
<script src="https://chaos-mesh.dev/godoc/release-2.1/lib/godoc/jquery.js" defer=""></script>




<script>var goVersion = "go1.18.1";</script>
<script src="https://chaos-mesh.dev/godoc/release-2.1/lib/godoc/godocs.js" defer=""></script>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async="" src="https://www.googletagmanager.com/gtag/js?id=G-7DESCBGPBX"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());

  gtag('config', 'G-7DESCBGPBX');
</script>
</head>
<body>

<div id="lowframe" style="position: fixed; bottom: 0; left: 0; height: 0; width: 100%; border-top: thin solid grey; background-color: white; overflow: auto;">
...
</div><!-- #lowframe -->

<div id="topbar" class="wide"><div class="container">
<div class="top-heading" id="heading-wide"><a href="https:/chaos-mesh.dev/godoc/release-2.1/pkg/github.com/chaos-mesh/chaos-mesh/">Chaos Mesh | Commit b41f5c5. Generated at Fri May 12 10:03:01 UTC 2023.</a></div>
<div class="top-heading" id="heading-narrow"><a href="https:/chaos-mesh.dev/godoc/release-2.1/pkg/github.com/chaos-mesh/chaos-mesh/">Chaos Mesh</a></div>
<a href="#" id="menu-button"><span id="menu-button-arrow">▽</span></a>

</div></div>



<div id="page" class="wide">
<div class="container">


  <h1>
    Source file
    <a href="https:/chaos-mesh.dev/godoc/release-2.1/src">src</a>/<a href="https:/chaos-mesh.dev/godoc/release-2.1/src/github.com">github.com</a>/<a href="https:/chaos-mesh.dev/godoc/release-2.1/src/github.com/chaos-mesh">chaos-mesh</a>/<a href="https:/chaos-mesh.dev/godoc/release-2.1/src/github.com/chaos-mesh/chaos-mesh">chaos-mesh</a>/<a href="https:/chaos-mesh.dev/godoc/release-2.1/src/github.com/chaos-mesh/chaos-mesh/pkg">pkg</a>/<a href="https:/chaos-mesh.dev/godoc/release-2.1/src/github.com/chaos-mesh/chaos-mesh/pkg/time">time</a>/<span class="text-muted">asset.go</span>
  </h1>





  <h2>
    Documentation: <a href="https:/chaos-mesh.dev/godoc/release-2.1/pkg/github.com/chaos-mesh/chaos-mesh/pkg/time">github.com/chaos-mesh/chaos-mesh/pkg/time</a>
  </h2>



<div id="nav"></div>


<script type="text/javascript">document.ANALYSIS_DATA = null;</script>
<pre><span id="L1" class="ln">     1  </span><span class="comment">// Copyright 2021 Chaos Mesh Authors.</span>
<span id="L2" class="ln">     2  </span><span class="comment">//</span>
<span id="L3" class="ln">     3  </span><span class="comment">// Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);</span>
<span id="L4" class="ln">     4  </span><span class="comment">// you may not use this file except in compliance with the License.</span>
<span id="L5" class="ln">     5  </span><span class="comment">// You may obtain a copy of the License at</span>
<span id="L6" class="ln">     6  </span><span class="comment">//</span>
<span id="L7" class="ln">     7  </span><span class="comment">// http://www.apache.org/licenses/LICENSE-2.0</span>
<span id="L8" class="ln">     8  </span><span class="comment">//</span>
<span id="L9" class="ln">     9  </span><span class="comment">// Unless required by applicable law or agreed to in writing, software</span>
<span id="L10" class="ln">    10  </span><span class="comment">// distributed under the License is distributed on an &#34;AS IS&#34; BASIS,</span>
<span id="L11" class="ln">    11  </span><span class="comment">// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.</span>
<span id="L12" class="ln">    12  </span><span class="comment">// See the License for the specific language governing permissions and</span>
<span id="L13" class="ln">    13  </span><span class="comment">// limitations under the License.</span>
<span id="L14" class="ln">    14  </span><span class="comment">//</span>
<span id="L15" class="ln">    15  </span>
<span id="L16" class="ln">    16  </span>package time
<span id="L17" class="ln">    17  </span>
<span id="L18" class="ln">    18  </span>import (
<span id="L19" class="ln">    19  </span>	&#34;bytes&#34;
<span id="L20" class="ln">    20  </span>	&#34;debug/elf&#34;
<span id="L21" class="ln">    21  </span>	&#34;embed&#34;
<span id="L22" class="ln">    22  </span>	&#34;encoding/binary&#34;
<span id="L23" class="ln">    23  </span>
<span id="L24" class="ln">    24  </span>	&#34;github.com/go-logr/logr&#34;
<span id="L25" class="ln">    25  </span>	&#34;github.com/pkg/errors&#34;
<span id="L26" class="ln">    26  </span>)
<span id="L27" class="ln">    27  </span>
<span id="L28" class="ln">    28  </span><span class="comment">//go:embed fakeclock/*.o</span>
<span id="L29" class="ln">    29  </span>var fakeclock embed.FS
<span id="L30" class="ln">    30  </span>
<span id="L31" class="ln">    31  </span>const textSection = &#34;.text&#34;
<span id="L32" class="ln">    32  </span>const relocationSection = &#34;.rela.text&#34;
<span id="L33" class="ln">    33  </span>
<span id="L34" class="ln">    34  </span><span class="comment">// LoadFakeImageFromEmbedFs builds FakeImage from the embed filesystem. It parses the ELF file and extract the variables from the relocation section, reserves the space for them at the end of content, then calculates and saves offsets as &#34;manually relocation&#34;</span>
<span id="L35" class="ln">    35  </span>func LoadFakeImageFromEmbedFs(filename string, symbolName string, logger logr.Logger) (*FakeImage, error) {
<span id="L36" class="ln">    36  </span>	path := &#34;fakeclock/&#34; + filename
<span id="L37" class="ln">    37  </span>	object, err := fakeclock.ReadFile(path)
<span id="L38" class="ln">    38  </span>	if err != nil {
<span id="L39" class="ln">    39  </span>		return nil, errors.Wrapf(err, &#34;read file from embedded fs %s&#34;, path)
<span id="L40" class="ln">    40  </span>	}
<span id="L41" class="ln">    41  </span>
<span id="L42" class="ln">    42  </span>	elfFile, err := elf.NewFile(bytes.NewReader(object))
<span id="L43" class="ln">    43  </span>	if err != nil {
<span id="L44" class="ln">    44  </span>		return nil, errors.Wrapf(err, &#34;parse elf file %s&#34;, path)
<span id="L45" class="ln">    45  </span>	}
<span id="L46" class="ln">    46  </span>
<span id="L47" class="ln">    47  </span>	syms, err := elfFile.Symbols()
<span id="L48" class="ln">    48  </span>	if err != nil {
<span id="L49" class="ln">    49  </span>		return nil, errors.Wrapf(err, &#34;get symbols %s&#34;, path)
<span id="L50" class="ln">    50  </span>	}
<span id="L51" class="ln">    51  </span>
<span id="L52" class="ln">    52  </span>	var imageContent []byte
<span id="L53" class="ln">    53  </span>	imageOffset := make(map[string]int)
<span id="L54" class="ln">    54  </span>
<span id="L55" class="ln">    55  </span>	for _, r := range elfFile.Sections {
<span id="L56" class="ln">    56  </span>
<span id="L57" class="ln">    57  </span>		if r.Type == elf.SHT_PROGBITS &amp;&amp; r.Name == textSection {
<span id="L58" class="ln">    58  </span>			imageContent, err = r.Data()
<span id="L59" class="ln">    59  </span>			if err != nil {
<span id="L60" class="ln">    60  </span>				return nil, errors.Wrapf(err, &#34;read text section data %s&#34;, path)
<span id="L61" class="ln">    61  </span>			}
<span id="L62" class="ln">    62  </span>			break
<span id="L63" class="ln">    63  </span>		}
<span id="L64" class="ln">    64  </span>	}
<span id="L65" class="ln">    65  </span>
<span id="L66" class="ln">    66  </span>	for _, r := range elfFile.Sections {
<span id="L67" class="ln">    67  </span>		if r.Type == elf.SHT_RELA &amp;&amp; r.Name == relocationSection {
<span id="L68" class="ln">    68  </span>			rela_section, err := r.Data()
<span id="L69" class="ln">    69  </span>			if err != nil {
<span id="L70" class="ln">    70  </span>				return nil, errors.Wrapf(err, &#34;read rela section data %s&#34;, path)
<span id="L71" class="ln">    71  </span>			}
<span id="L72" class="ln">    72  </span>			rela_section_reader := bytes.NewReader(rela_section)
<span id="L73" class="ln">    73  </span>
<span id="L74" class="ln">    74  </span>			var rela elf.Rela64
<span id="L75" class="ln">    75  </span>			for rela_section_reader.Len() &gt; 0 {
<span id="L76" class="ln">    76  </span>				err := binary.Read(rela_section_reader, elfFile.ByteOrder, &amp;rela)
<span id="L77" class="ln">    77  </span>				if err != nil {
<span id="L78" class="ln">    78  </span>					return nil, errors.Wrapf(err, &#34;read rela section rela64 entry %s&#34;, path)
<span id="L79" class="ln">    79  </span>				}
<span id="L80" class="ln">    80  </span>
<span id="L81" class="ln">    81  </span>				symNo := rela.Info &gt;&gt; 32
<span id="L82" class="ln">    82  </span>				if symNo == 0 || symNo &gt; uint64(len(syms)) {
<span id="L83" class="ln">    83  </span>					continue
<span id="L84" class="ln">    84  </span>				}
<span id="L85" class="ln">    85  </span>
<span id="L86" class="ln">    86  </span>				<span class="comment">// The relocation of a X86 image is like:</span>
<span id="L87" class="ln">    87  </span>				<span class="comment">// Relocation section &#39;.rela.text&#39; at offset 0x288 contains 3 entries:</span>
<span id="L88" class="ln">    88  </span>				<span class="comment">// Offset          Info           Type           Sym. Value    Sym. Name + Addend</span>
<span id="L89" class="ln">    89  </span>				<span class="comment">// 000000000016  000900000002 R_X86_64_PC32     0000000000000000 CLOCK_IDS_MASK - 4</span>
<span id="L90" class="ln">    90  </span>				<span class="comment">// 00000000001f  000a00000002 R_X86_64_PC32     0000000000000008 TV_NSEC_DELTA - 4</span>
<span id="L91" class="ln">    91  </span>				<span class="comment">// 00000000002a  000b00000002 R_X86_64_PC32     0000000000000010 TV_SEC_DELTA - 4</span>
<span id="L92" class="ln">    92  </span>				<span class="comment">//</span>
<span id="L93" class="ln">    93  </span>				<span class="comment">// For example, we need to write the offset of `CLOCK_IDS_MASK` - 4 in 0x16 of the section</span>
<span id="L94" class="ln">    94  </span>				<span class="comment">// If we want to put the `CLOCK_IDS_MASK` at the end of the section, it will be</span>
<span id="L95" class="ln">    95  </span>				<span class="comment">// len(fakeImage.content) - 4 - 0x16</span>
<span id="L96" class="ln">    96  </span>
<span id="L97" class="ln">    97  </span>				sym := &amp;syms[symNo-1]
<span id="L98" class="ln">    98  </span>				imageOffset[sym.Name] = len(imageContent)
<span id="L99" class="ln">    99  </span>				targetOffset := uint32(len(imageContent)) - uint32(rela.Off) + uint32(rela.Addend)
<span id="L100" class="ln">   100  </span>				elfFile.ByteOrder.PutUint32(imageContent[rela.Off:rela.Off+4], targetOffset)
<span id="L101" class="ln">   101  </span>
<span id="L102" class="ln">   102  </span>				<span class="comment">// TODO: support other length besides uint64 (which is 8 bytes)</span>
<span id="L103" class="ln">   103  </span>				imageContent = append(imageContent, make([]byte, 8)...)
<span id="L104" class="ln">   104  </span>			}
<span id="L105" class="ln">   105  </span>
<span id="L106" class="ln">   106  </span>			break
<span id="L107" class="ln">   107  </span>		}
<span id="L108" class="ln">   108  </span>	}
<span id="L109" class="ln">   109  </span>	return NewFakeImage(
<span id="L110" class="ln">   110  </span>		symbolName,
<span id="L111" class="ln">   111  </span>		imageContent,
<span id="L112" class="ln">   112  </span>		imageOffset,
<span id="L113" class="ln">   113  </span>		logger,
<span id="L114" class="ln">   114  </span>	), nil
<span id="L115" class="ln">   115  </span>}
<span id="L116" class="ln">   116  </span>
</pre><p></p>

<div id="footer">
Build version go1.18.1.<br/>
</div>

</div><!-- .container -->
</div><!-- #page -->


</body></html>